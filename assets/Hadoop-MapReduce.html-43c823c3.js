import{_ as s,V as e,W as t,X as p,Z as n,a0 as l,Y as o,a1 as i,C as c}from"./framework-25aba5a5.js";const r={},u=n("p",null,"MapReduce的核心思想是”分而治之“。",-1),d=i(`<h2 id="mapreduce介绍" tabindex="-1"><a class="header-anchor" href="#mapreduce介绍" aria-hidden="true">#</a> MapReduce介绍</h2><h3 id="mapreduce设计构思" tabindex="-1"><a class="header-anchor" href="#mapreduce设计构思" aria-hidden="true">#</a> MapReduce设计构思</h3><p>MaReduce是一个分布式运算程序的编程框架，简化了并行计算，降低并行应用的入门门槛。其设计思想体现如下：</p><ol><li><strong>分而治之</strong></li></ol><p>对互相之间不具备计算依赖关系的大数据才去分而治之的策略</p><ol start="2"><li><strong>Map和Reduce</strong></li></ol><p>用Map和Reduce提供了高阶的并行编程抽象模型</p><p>Map：对一组数据进行某种重复式的处理</p><p>Reduce: 对Map的中间结果进行进一步的整理</p><p>MapReduce 定义了两个抽象的编程接口，让用户实现：</p><p>map: (k1; v1) -&gt;[(k2; v2)]</p><p>Reduce: (k2; [v2]) -&gt; [(k3; v3)]</p><ol start="3"><li><strong>MR框架</strong><ol><li>MR AppMaster: 负责整个程序的过程调度和状态协调</li><li>MapTask： 负责map阶段的数据处理</li><li>ReduceTask： 负责Reduce阶段的数据处理</li></ol></li></ol><h2 id="mr编程规范" tabindex="-1"><a class="header-anchor" href="#mr编程规范" aria-hidden="true">#</a> MR编程规范</h2><blockquote><p>MR的开发一共8个步骤，Map:2 Shuffle:4 Reduce:2</p></blockquote><ol><li><p>Map阶段</p><ol><li>设置InputFormat类，将数据切分为（k1,v1)</li><li>自定义Map逻辑，将上述的输入转换为（k2,v2)</li></ol></li><li><p>Shuffle阶段</p><ol><li>对k2v2进行分区</li><li>对不同分区的数据按照相同的key进行排序</li><li>对分组过的数据进行初步规约，降低数据的网络拷贝</li><li>对数据进行分组，相同的key和val放入同一个集合中</li></ol></li><li><p>Reduce阶段</p><ol><li>对多个Map任务的结果进行排序以及合并，编写Reduce实现自己的逻辑，转为新的k3v3</li><li>设置OutputFormat处理并保存Reduce输出的kv数据</li></ol></li></ol><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230308163234554.png" alt="image-20230308163234554" tabindex="0" loading="lazy"><figcaption>image-20230308163234554</figcaption></figure><h2 id="mapper、reducer抽象类介绍" tabindex="-1"><a class="header-anchor" href="#mapper、reducer抽象类介绍" aria-hidden="true">#</a> Mapper、Reducer抽象类介绍</h2><p>上述的八个步骤都是一个class类。MR中，最重要的就是mapper和Reducer类</p><ol><li><strong>Mapper抽象类</strong></li></ol><p>四个重要方法</p><ul><li>setup 初始化方法</li><li>map：读取的每一行数据，会调用一次map</li><li>cleanup：maptask执行完之后，会调用cleanup。可以做一些连接断开，资源关闭的操作</li><li>run：更精细的控制MapTask的执行</li></ul><ol start="2"><li><strong>Reducer抽象类</strong></li></ol><ul><li>setup</li><li>reduce</li><li>cleanup</li><li>run</li></ul><h2 id="wordcount示例" tabindex="-1"><a class="header-anchor" href="#wordcount示例" aria-hidden="true">#</a> WordCount示例</h2><ol start="0"><li><p>数据准备</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /export/servers
<span class="token function">vim</span> wordcount.txt
<span class="token comment">#添加以下内容: </span>
hello hello 
world world 
hadoop hadoop 
hello world 
hello flume 
hadoop hive 
hive kafka 
flume storm 
hive oozie

hdfs dfs <span class="token parameter variable">-mkdir</span> /wordcount/
hdfs dfs <span class="token parameter variable">-put</span> wordcount.txt /wordcount/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>定义mapper类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
keyin : long -&gt; LongWritable
valin: String -&gt; Text
keyout: String -&gt; Text
valout: Long -&gt; LongWritable
**/</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapTask</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
  
  <span class="token comment">/*
  context:上下文对象
  */</span>
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">LongWritable</span> key<span class="token punctuation">,</span> <span class="token class-name">Text</span> value<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//1. 获取v1的数据，文本中的一行</span>
    <span class="token class-name">String</span> val <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//2. 切割单词</span>
    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token class-name">Text</span> text <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">LongWritable</span> longWritable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3. 遍历单词，发给reduce</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> word <span class="token operator">:</span> words<span class="token punctuation">)</span><span class="token punctuation">{</span>
      text<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">;</span>
      context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span> longWritable<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>定义Reducer类</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReduceTask</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">,</span> <span class="token class-name">Text</span><span class="token punctuation">,</span> <span class="token class-name">LongWritable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Text</span> key<span class="token punctuation">,</span> <span class="token class-name">Interable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">LongWritable</span><span class="token punctuation">&gt;</span></span> values<span class="token punctuation">,</span> <span class="token class-name">Context</span> context<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">long</span> v3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">LongWritable</span> longWritable <span class="token operator">:</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
      v3 <span class="token operator">+=</span> longWritable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LongWritable</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>定义主类，提交任务</p></li></ol><p>​ 略</p><h2 id="mr的运行机制-重要" tabindex="-1"><a class="header-anchor" href="#mr的运行机制-重要" aria-hidden="true">#</a> MR的运行机制（重要）</h2><h3 id="maptask工作机制" tabindex="-1"><a class="header-anchor" href="#maptask工作机制" aria-hidden="true">#</a> MapTask工作机制</h3><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230308170135429.png" alt="image-20230308170135429" style="zoom:67%;"><ol><li><p>数据读取组件<strong>InputFormat</strong>(默认为TextInputFormat)会通过<strong>getSplits</strong>方法对输入目录中文件进行逻辑切片规划得到<strong>split</strong>，有多少个split就启动多少个<strong>MapTask</strong></p><blockquote><p>关于split与block</p></blockquote></li><li><p>将输入文件切分为split之后，由<strong>RecordReader</strong>对象（默认为LineRecordReader）进行读取，以**\\n<strong>作为分隔符，返回</strong>&lt;key,value&gt;<strong>,key表示每行首字符的</strong>偏移值**，Value表示这一行文本内容</p></li><li><p>&lt;key,value&gt;进入用户自定义的Mapper类，执行<strong>map函数</strong>。每读取一行，调用一次</p><p><strong>以下是Map的shuffle过程</strong></p></li><li><p>Mapper逻辑结束后，将Mapper的每条结果通过<strong>context.write</strong>进行collect数据收集。在collector中，会先进行<strong>分区处理</strong>。</p><blockquote><p>Partitioner，根据Key或Value以及Reducer的数量决定当前的数据输出交给哪个Reduce Task处理。 默认HashPartitioner<strong>对Key Hash后再以Reducer的数量取模</strong>。</p><p>对于数据不平衡的情况，可能就要自定义分区算法</p></blockquote></li><li><p>数据写入内存(<strong>环形缓冲区</strong>)，作用是收集mapper结果，减少磁盘IO的影响。</p><blockquote><p>环形缓冲器是一个数组，存放kv的序列化数据、元数据信息（分区、kv的起始位置、value的长度)</p><p>缓冲区默认的大小是100M。 当缓冲区的数据达到阈值（默认0.8*100=80MB)，会spill溢写数据到磁盘。溢写程序是一个单独的线程，锁定80M内存，输出结果往剩下的20M内存中写。</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/20151017165918130.jpeg" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>存在缓冲区的数据包括存放kv数据的kvbuffer和存放索引的kvmeta。</p><p>索引包括：value的起始位置、key的起始位置、partition的值、value的长度</p></blockquote></li><li><p><strong>排序(sort)</strong>,对80MB空间内的Key做排序。如果设置为<strong>Combiner</strong>，在之后会将具有相同key的kv的v合并在一起。</p><blockquote><p>程序先把Kvbuffer中的数据按照partition值和key两个关键字升序排序(快速排序），<strong>移动的只是索引数据</strong>，排序结果是Kvmeta中数据按照partition为单位聚集在一起，同一partition内的按照key有序。</p></blockquote></li><li><p><strong>溢写文件(spill)</strong>。Spill线程根据排过序的Kvmeta挨个partition的把数据吐到溢写文件.out中，一个partition对应的数据吐完之后顺序地吐下个partition，直到把所有的partition遍历完。一个partition在文件中对应的数据也叫段(segment)。</p><blockquote><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/20151017173908750.png" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure></blockquote></li><li><p><strong>归并(merge)</strong>。针对同一个Mapper的多个spill文件的merge。如果文件比较大，会进行多次spill，产生多个spill文件，需要对多个溢写文件进行归并(merge)并排序，如果有Combine则进行，最后保存为一个文件写入磁盘，并为这个文件提供一个索引，记录每个partition对应的数据偏移量。</p><blockquote><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/20151017180604215.png" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><p>使用堆排序，</p><p>归并：&lt;a,1&gt;,&lt;a,2&gt; =&gt; &lt;a,[1,2]&gt; ？纠正：map端应该是没有这个操作的</p></blockquote></li></ol><h3 id="reducetask工作机制" tabindex="-1"><a class="header-anchor" href="#reducetask工作机制" aria-hidden="true">#</a> ReduceTask工作机制</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230308172158541.png" alt="image-20230308172158541" tabindex="0" loading="lazy"><figcaption>image-20230308172158541</figcaption></figure><ol><li><strong>Copy阶段</strong>。Reduce进行启动<strong>Fetcher线程</strong>去copy数据，通过<strong>http方式请求</strong>MapTask获取属于自己的文件</li><li><strong>Merge阶段</strong>。针对不同Mapper的partition数据进行的merge。从不同map端copy过来的数据会存放在内存缓存区中。达到溢写条件时，会在磁盘中生成溢写文件（inMemoryMerger），然后启动磁盘到磁盘的Merge方式生成最终的文件（onDiskMerger）。</li><li>归并排序。把分散的数据合并成一个大的数据后，还会再对合并后的数据进行排序</li><li>对排序后的kv调用Reduce方法。键相等的键值对调用一次reduce方法，产生零个或多个键值对，把输出kv写到hdfs文件中。</li></ol><h3 id="shuffle过程" tabindex="-1"><a class="header-anchor" href="#shuffle过程" aria-hidden="true">#</a> Shuffle过程</h3><p>map阶段处理的数据传递给reduce阶段的流程称为shuffle。</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230308195953223.png" alt="image-20230308195953223" tabindex="0" loading="lazy"><figcaption>image-20230308195953223</figcaption></figure><ol><li><strong>collect阶段</strong>。将MapTask的结果输出到默认为100M的环形缓冲区，保存的是kv、partition分区等信息</li><li><strong>spill阶段</strong>。达到阈值时，溢写到本地磁盘，在写之前有一次排序的操作，如果配置里combiner，还会将有相同分区号和key的数据进行排序</li><li><strong>merge阶段</strong>。把所有溢写的临时文件进行一次合并操作，确保一个MapTask产生一个中间数据文件</li><li><strong>copy阶段</strong>。reduceTask启动fetcher线程到以及完成MapTask的节点上复制自己的数据，默认保存在缓冲区中，达到阈值后，写到磁盘上</li><li><strong>merge阶段</strong>。在ReduceTask复制数据的同时，后台会开启两个线程对内存到本地的数据文件进行合并操作</li><li><strong>sort阶段</strong>。在合并的同时，会进行排序操作，MapTask以及进行了局部的排序，ReduceTask只需要保证copy的数据的最终整体有效性即可。</li></ol><h2 id="例-社交粉丝数据分析" tabindex="-1"><a class="header-anchor" href="#例-社交粉丝数据分析" aria-hidden="true">#</a> 例：社交粉丝数据分析</h2><h3 id="需求" tabindex="-1"><a class="header-anchor" href="#需求" aria-hidden="true">#</a> 需求</h3><blockquote><p>以下是 qq 的好友列表数据，冒号前是一个用户，冒号后是该用户的所有好友(数 据中的好友关系是单向的) A:B,C,D,F,E,O</p><p>B:A,C,E,K</p><p>C:A,B,D,E,I</p><p>D:A,E,F,L</p><p>E:B,C,D,M,L</p><p>F:A,B,C,D,E,O,M</p><p>求出哪些人两两之间有共同好友，及他俩的共同好友都有谁?</p></blockquote><h3 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h3><ul><li>第一步</li></ul><p>Map</p><p>读一行 A：B，C，D，F，E，O</p><p>输出：&lt;A,B&gt;、&lt;A,C&gt;、&lt;A,D&gt;、&lt;A,F&gt;、&lt;A,E&gt;、&lt;A,O&gt;</p><p>Reduce</p><p>拿到数据&lt;C,A&gt;&lt;C,B&gt;&lt;C,E&gt;&lt;C,F&gt;&lt;C,G&gt;... 相同的key会分到了一个MapTask</p><p>输出：&lt;A-B-E-,C&gt;</p><p>..</p><ul><li>第二步</li></ul><p>Map</p><p>读&lt;A-B-E-,C&gt;</p><p>输出&lt;A-B,C&gt;、&lt;A-E,C&gt;</p><p>Reduce 读&lt;A-B,C&gt;、&lt;A-B,E&gt;</p><p>输出：&lt;A-B ，CE&gt;</p>`,56),k=n("p",null,"参考",-1),g={href:"https://blog.csdn.net/u014374284/article/details/49205885",target:"_blank",rel:"noopener noreferrer"},m=n("li",null,null,-1);function v(h,b){const a=c("ExternalLinkIcon");return e(),t("div",null,[u,p(" more "),d,n("blockquote",null,[k,n("ol",null,[n("li",null,[n("a",g,[l(" MapReduce shuffle过程详解_xidianycy的博客-CSDN博客"),o(a)])]),m])])])}const M=s(r,[["render",v],["__file","Hadoop-MapReduce.html.vue"]]);export{M as default};
