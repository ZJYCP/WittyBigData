import{_ as o,V as p,W as i,X as c,Z as n,a0 as a,Y as t,a1 as e,C as l}from"./framework-25aba5a5.js";const u={},r=n("p",null,"本章主要介绍Kafka 消费者",-1),d=e(`<h2 id="kafka消费方式" tabindex="-1"><a class="header-anchor" href="#kafka消费方式" aria-hidden="true">#</a> Kafka消费方式</h2><ul><li>拉模式</li><li>推模式</li></ul><p>pull模式不足之处，如果Kafka没有数据，消费者可能会陷入循环，一直返回空数据</p><h2 id="kafka消费者工作流程" tabindex="-1"><a class="header-anchor" href="#kafka消费者工作流程" aria-hidden="true">#</a> Kafka消费者工作流程</h2><h3 id="消费者总体工作流程" tabindex="-1"><a class="header-anchor" href="#消费者总体工作流程" aria-hidden="true">#</a> 消费者总体工作流程</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508140213823.png" alt="消费者" tabindex="0" loading="lazy"><figcaption>消费者</figcaption></figure><h3 id="消费者组原理" tabindex="-1"><a class="header-anchor" href="#消费者组原理" aria-hidden="true">#</a> 消费者组原理</h3><ul><li>消费者组（Consumer Group，CG），由多个Consumer组成</li><li>消费者组每个消费者负责消费不同分区的数据，<strong>一个分区只能由一个组内消费者消费</strong></li><li>消费者组之间互不影响，消费者组是逻辑上的一个订阅者</li><li>超过主题分区数量，有一部分消费者会闲置不接受任何消息</li></ul><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508152155712.png" alt="消费者组" tabindex="0" loading="lazy"><figcaption>消费者组</figcaption></figure><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508152220795.png" alt="消费者组" tabindex="0" loading="lazy"><figcaption>消费者组</figcaption></figure><h3 id="消费者组初始化流程" tabindex="-1"><a class="header-anchor" href="#消费者组初始化流程" aria-hidden="true">#</a> 消费者组初始化流程</h3><ul><li>coordinator：辅助实现消费者组的初始化和分区的分配</li></ul><p>coordinate节点选择 = groupid的hashcode % 50 （__consumer_offsets的分区数量）</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508152702172.png" alt="消费者组初始化" tabindex="0" loading="lazy"><figcaption>消费者组初始化</figcaption></figure><h3 id="消费者组详细消费流程" tabindex="-1"><a class="header-anchor" href="#消费者组详细消费流程" aria-hidden="true">#</a> 消费者组详细消费流程</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508154027174.png" alt="image-20230508154027174" tabindex="0" loading="lazy"><figcaption>image-20230508154027174</figcaption></figure><h2 id="消费者api" tabindex="-1"><a class="header-anchor" href="#消费者api" aria-hidden="true">#</a> 消费者API</h2><h3 id="独立消费者" tabindex="-1"><a class="header-anchor" href="#独立消费者" aria-hidden="true">#</a> 独立消费者</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomConsumer</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 1.创建消费者的配置对象</span>
<span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2.给消费者配置对象添加参数</span>
properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ConsumerConfig</span><span class="token punctuation">.</span><span class="token constant">BOOTSTRAP_SERVERS_CONFIG</span><span class="token punctuation">,</span> <span class="token string">&quot;hadoop102:9092&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 配置序列化 必须 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span>
properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ConsumerConfig</span><span class="token punctuation">.</span><span class="token constant">VALUE_DESERIALIZER_CLASS_CONFIG</span><span class="token punctuation">,</span> <span class="token class-name">StringDeserializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 配置消费者组(组名任意起名) 必须 properties.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;test&quot;);</span>
<span class="token comment">// 创建消费者对象</span>
<span class="token class-name">KafkaConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> kafkaConsumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaConsumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注册要消费的主题(可以消费多个主题) </span>
  <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> topics <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> topics<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;first&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> kafkaConsumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topics<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 拉取数据打印</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 设置 1s 中消费一批数据</span>
<span class="token class-name">ConsumerRecords</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> consumerRecords <span class="token operator">=</span>
kafkaConsumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印消费到的数据</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ConsumerRecord</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> consumerRecord <span class="token operator">:</span> consumerRecords<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="订阅分区" tabindex="-1"><a class="header-anchor" href="#订阅分区" aria-hidden="true">#</a> 订阅分区</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 消费某个主题的某个分区数据</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">&gt;</span></span> topicPartitions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
topicPartitions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">(</span><span class="token string">&quot;first&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> kafkaConsumer<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>topicPartitions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="消费者组案例" tabindex="-1"><a class="header-anchor" href="#消费者组案例" aria-hidden="true">#</a> 消费者组案例</h3><p>复制一份基础消费者的代码，在 IDEA 中同时启动，即可启动同一个消费者组中的两个消费者</p><ul><li>控制消费者组ID相同</li></ul><h2 id="分区的分配和再平衡" tabindex="-1"><a class="header-anchor" href="#分区的分配和再平衡" aria-hidden="true">#</a> 分区的分配和再平衡</h2><p>解决消费者消费哪个partition</p><ul><li>Kafka有四种主流的分区分配策略: <strong>Range、RoundRobin、Sticky、CooperativeSticky</strong>。可以通过配置参数partition.assignment.strategy，修改分区的分配策略。默认策略是Range+ CooperativeSticky</li></ul><h3 id="range" tabindex="-1"><a class="header-anchor" href="#range" aria-hidden="true">#</a> Range</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508155513104.png" alt="Range" tabindex="0" loading="lazy"><figcaption>Range</figcaption></figure><ol><li><p>首先对同一个 topic 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序</p></li><li><p>通过 partitions数/consumer数 来决定每个消费者应该消费几个分区。<strong>如果除不尽，那么前面几个消费者将会多消费 1 个分区</strong></p></li></ol><p>注意如果有N个topic，那么C0都将多消费1个分区的数据，容易产生<strong>数据倾斜</strong></p><h3 id="range再平衡" tabindex="-1"><a class="header-anchor" href="#range再平衡" aria-hidden="true">#</a> Range再平衡</h3><p>0 号消费者挂掉后，消费者组需要按照超时时间 45s 来判断它是否退出，所以需要等待，时间到了 45s 后，判断它真的退出就会把任务分配给其他 broker 执行。</p><h3 id="roundrobin" tabindex="-1"><a class="header-anchor" href="#roundrobin" aria-hidden="true">#</a> RoundRobin</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508161611716.png" alt="RoundRobin" tabindex="0" loading="lazy"><figcaption>RoundRobin</figcaption></figure><ul><li><p>RoundRobin 针对集群中<strong>所有Topic而言</strong></p></li><li><p>RoundRobin 轮询分区策略，是把所有的 partition 和所有的 consumer 都列出来，然后按照 <strong>hashcode</strong> 进行排序，最后 通过<strong>轮询算法</strong>来分配 partition 给到各个消费者</p></li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 修改分区分配策略 </span>
properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ConsumerConfig</span><span class="token punctuation">.</span><span class="token constant">PARTITION_ASSIGNMENT_STRATEGY_CONFI</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token string">&quot;org.apache.kafka.clients.consumer.RoundRobinAssignor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="sticky以及再平衡" tabindex="-1"><a class="header-anchor" href="#sticky以及再平衡" aria-hidden="true">#</a> Sticky以及再平衡</h3><p>粘性分区定义:可以理解为分配的结果带有“粘性的”。即在执行一次新的分配之前， 考虑上一次分配的结果，尽量少的调整分配的变动，可以节省大量的开销</p><p>粘性分区是 Kafka 从 0.11.x 版本开始引入这种分配策略，首先会<strong>尽量均衡的放置分区到消费者上面</strong>，在出现同一消费者组内消费者出现问题的时候，会尽量<strong>保持原有分配的分区不变化</strong></p><h2 id="offset位移" tabindex="-1"><a class="header-anchor" href="#offset位移" aria-hidden="true">#</a> Offset位移</h2><h3 id="offset维护位置" tabindex="-1"><a class="header-anchor" href="#offset维护位置" aria-hidden="true">#</a> offset维护位置</h3><p>消费者Offset消费信息维护在Kafka内置的主题__consumer_offsets中，0.9版本之前在zk中</p>`,43),k={href:"http://group.id",target:"_blank",rel:"noopener noreferrer"},m=n("p",null,[a("默认不能消费系统主题，在配置文件中添加配置"),n("code",null,"exclude.internal.topics=false")],-1),g=n("h3",{id:"自动提交offset",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#自动提交offset","aria-hidden":"true"},"#"),a(" 自动提交offset")],-1),h=n("li",null,"enable.auto.commit，默认true",-1),f={href:"http://auto.commit.interval.ms",target:"_blank",rel:"noopener noreferrer"},v=e(`<figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508162949634.png" alt="image-20230508162949634" tabindex="0" loading="lazy"><figcaption>image-20230508162949634</figcaption></figure><h3 id="手动提交offset" tabindex="-1"><a class="header-anchor" href="#手动提交offset" aria-hidden="true">#</a> 手动提交offset</h3><h4 id="同步提交" tabindex="-1"><a class="header-anchor" href="#同步提交" aria-hidden="true">#</a> 同步提交</h4><p>必须等待offset提交完毕，再去消费下一批数据。</p><p>由于同步提交 offset 有失败重试机制，故更加可靠，但是由于一直等待提交结果，提交的效率比较低</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//是否自动提交offset</span>
properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">ConsumerConfig</span><span class="token punctuation">.</span><span class="token constant">ENABLE_AUTO_COMMIT_CONFIG</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 同步提交offset</span>
consumer<span class="token punctuation">.</span><span class="token function">commitSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="异步提交" tabindex="-1"><a class="header-anchor" href="#异步提交" aria-hidden="true">#</a> 异步提交</h4><p>发送完提交offset请求后，就开始消费下一批数据了</p><p>生产中，异步会更多一点</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 异步提交offset</span>
consumer<span class="token punctuation">.</span><span class="token function">commitAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="指定offset消费" tabindex="-1"><a class="header-anchor" href="#指定offset消费" aria-hidden="true">#</a> 指定offset消费</h3><ul><li>auto.offset.reset = earliest | latest | none</li></ul><ol><li>最早的</li><li>最新的，默认</li><li>none：未找到offset，抛异常</li><li>指定offset</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TopicPartition</span><span class="token punctuation">&gt;</span></span> assignment<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>assignment<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span> kafkaConsumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取消费者分区分配信息(有了分区分配信息才能开始消费) </span>
                  assignment <span class="token operator">=</span> kafkaConsumer<span class="token punctuation">.</span><span class="token function">assignment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 遍历所有分区，并指定 offset 从 1700 的位置开始消费 </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TopicPartition</span> tp<span class="token operator">:</span> assignment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            kafkaConsumer<span class="token punctuation">.</span><span class="token function">seek</span><span class="token punctuation">(</span>tp<span class="token punctuation">,</span> <span class="token number">1700</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="指定时间消费" tabindex="-1"><a class="header-anchor" href="#指定时间消费" aria-hidden="true">#</a> 指定时间消费</h3><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508165239805.png" alt="image-20230508165239805" tabindex="0" loading="lazy"><figcaption>image-20230508165239805</figcaption></figure><h3 id="漏消费和重复消费" tabindex="-1"><a class="header-anchor" href="#漏消费和重复消费" aria-hidden="true">#</a> 漏消费和重复消费</h3><h4 id="重复消费" tabindex="-1"><a class="header-anchor" href="#重复消费" aria-hidden="true">#</a> 重复消费</h4><p>自动提交offset引起</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508165616287.png" alt="重复消费" tabindex="0" loading="lazy"><figcaption>重复消费</figcaption></figure><h4 id="漏消费" tabindex="-1"><a class="header-anchor" href="#漏消费" aria-hidden="true">#</a> 漏消费</h4><p>设置为手动提交，offset被提交时，数据还在内存中未落盘</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508165750262.png" alt="漏提交" tabindex="0" loading="lazy"><figcaption>漏提交</figcaption></figure><h2 id="消费者事务" tabindex="-1"><a class="header-anchor" href="#消费者事务" aria-hidden="true">#</a> 消费者事务</h2><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230508165817939.png" alt="消费者事务" tabindex="0" loading="lazy"><figcaption>消费者事务</figcaption></figure><ul><li>Kafka消费端将消费过程和提交offset 过程做原子绑定</li></ul><h2 id="数据积压" tabindex="-1"><a class="header-anchor" href="#数据积压" aria-hidden="true">#</a> 数据积压</h2><ul><li>增加分区数量，同时提高消费者数量</li><li>如果下游数据处理不及时，提高每批次拉取的数据。如果拉取的数据过少，单位时间处理的数据小于生产速度，也会造成数据积压。 默认500条</li></ul>`,28);function b(_,x){const s=l("ExternalLinkIcon");return p(),i("div",null,[r,c(" more "),d,n("p",null,[a("__consumer_offsets：key是"),n("strong",null,[n("a",k,[a("group.id"),t(s)]),a(" + topic + 分区号")]),a("，value是当前offset的值")]),m,g,n("ul",null,[h,n("li",null,[n("a",f,[a("auto.commit.interval.ms"),t(s)]),a("，默认5s")])]),v])}const C=o(u,[["render",b],["__file","Kafka 消费者.html.vue"]]);export{C as default};
