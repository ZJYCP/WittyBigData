import{_ as a,V as e,W as r,$ as i,X as h,a1 as d}from"./framework-8aef05fa.js";const n={},t=h("p",null,"主要介绍Flink中的容错机制",-1),c=d('<h2 id="检查点" tabindex="-1"><a class="header-anchor" href="#检查点" aria-hidden="true">#</a> 检查点</h2><h3 id="检查点的保存" tabindex="-1"><a class="header-anchor" href="#检查点的保存" aria-hidden="true">#</a> 检查点的保存</h3><ol><li><p>周期性触发保存</p></li><li><p>保存的时间点</p><p>当所有的任务都恰好处理完一个相同的输入数据的时候，他们的状态被保存下来。</p><p>避免处理状态意外的额外的信息的存储，提高了输入点保存的效率。</p><p>另外，事务性</p></li><li><p>保存的具体流程</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230605170239406.png" alt="image-20230605170239406" tabindex="0" loading="lazy"><figcaption>image-20230605170239406</figcaption></figure></li></ol><h3 id="从检查点恢复状态" tabindex="-1"><a class="header-anchor" href="#从检查点恢复状态" aria-hidden="true">#</a> 从检查点恢复状态</h3><ol><li>重启应用</li><li>读取检查点，重置状态</li><li>重放数据</li><li>继续处理数据</li></ol><h3 id="检查点算法" tabindex="-1"><a class="header-anchor" href="#检查点算法" aria-hidden="true">#</a> 检查点算法</h3><h4 id="检查点边界线-barrier" tabindex="-1"><a class="header-anchor" href="#检查点边界线-barrier" aria-hidden="true">#</a> 检查点边界线(Barrier)</h4><p>在JobManager中有一个“<strong>检查点协调器</strong>”，专门用来协调处理检查点的相关工作。检查点协调器会定期向TaskManager发出指令，要求保存检查点（带着<strong>检查点ID</strong>）；TaskManager会让所有的Source任务把自己的偏移量（算子状态）保存起来，并将带有检查点ID的分界线插入到当前的数据流中，然后像正常的数据一样像下游传递；之后Source任务就可以继续读入新的数据了。</p><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230605171531361.png" alt="image-20230605171531361" tabindex="0" loading="lazy"><figcaption>image-20230605171531361</figcaption></figure><h4 id="分布式快照算法-barrier对齐的精准一次" tabindex="-1"><a class="header-anchor" href="#分布式快照算法-barrier对齐的精准一次" aria-hidden="true">#</a> 分布式快照算法(Barrier对齐的精准一次)</h4><p>异步分界线快照</p><ul><li>当上游向多个下游发送barrier，广播出去</li><li>多个上游任务向同一个下游传递时，等所有的都对齐</li></ul><h4 id="分布式快照算法-barrier对齐的至少一次" tabindex="-1"><a class="header-anchor" href="#分布式快照算法-barrier对齐的至少一次" aria-hidden="true">#</a> 分布式快照算法(Barrier对齐的至少一次)</h4><h4 id="分布式快照算法-非barrier对齐的精准一次" tabindex="-1"><a class="header-anchor" href="#分布式快照算法-非barrier对齐的精准一次" aria-hidden="true">#</a> 分布式快照算法(非Barrier对齐的精准一次)</h4><h3 id="检查点配置" tabindex="-1"><a class="header-anchor" href="#检查点配置" aria-hidden="true">#</a> 检查点配置</h3><h4 id="启用检查点" tabindex="-1"><a class="header-anchor" href="#启用检查点" aria-hidden="true">#</a> 启用检查点</h4><h4 id="检查点存储" tabindex="-1"><a class="header-anchor" href="#检查点存储" aria-hidden="true">#</a> 检查点存储</h4><h4 id="其他高级配置" tabindex="-1"><a class="header-anchor" href="#其他高级配置" aria-hidden="true">#</a> 其他高级配置</h4><h4 id="通用增量checkpoint" tabindex="-1"><a class="header-anchor" href="#通用增量checkpoint" aria-hidden="true">#</a> 通用增量checkpoint</h4><h4 id="最终检查点" tabindex="-1"><a class="header-anchor" href="#最终检查点" aria-hidden="true">#</a> 最终检查点</h4><h3 id="保存点" tabindex="-1"><a class="header-anchor" href="#保存点" aria-hidden="true">#</a> 保存点</h3><h4 id="保存点的用途" tabindex="-1"><a class="header-anchor" href="#保存点的用途" aria-hidden="true">#</a> 保存点的用途</h4><h4 id="使用保存点" tabindex="-1"><a class="header-anchor" href="#使用保存点" aria-hidden="true">#</a> 使用保存点</h4><h4 id="使用保存点切换状态后端" tabindex="-1"><a class="header-anchor" href="#使用保存点切换状态后端" aria-hidden="true">#</a> 使用保存点切换状态后端</h4><h2 id="状态一致性" tabindex="-1"><a class="header-anchor" href="#状态一致性" aria-hidden="true">#</a> 状态一致性</h2><h3 id="一致性的概念和级别" tabindex="-1"><a class="header-anchor" href="#一致性的概念和级别" aria-hidden="true">#</a> 一致性的概念和级别</h3><h3 id="端到端的状态一致性" tabindex="-1"><a class="header-anchor" href="#端到端的状态一致性" aria-hidden="true">#</a> 端到端的状态一致性</h3><h2 id="端到端精确一次" tabindex="-1"><a class="header-anchor" href="#端到端精确一次" aria-hidden="true">#</a> 端到端精确一次</h2><h3 id="输入端保证" tabindex="-1"><a class="header-anchor" href="#输入端保证" aria-hidden="true">#</a> 输入端保证</h3><h3 id="输出端保证" tabindex="-1"><a class="header-anchor" href="#输出端保证" aria-hidden="true">#</a> 输出端保证</h3><h3 id="flink和kafka连接时的精确一次保证" tabindex="-1"><a class="header-anchor" href="#flink和kafka连接时的精确一次保证" aria-hidden="true">#</a> Flink和Kafka连接时的精确一次保证</h3>',31);function s(l,o){return e(),r("div",null,[t,i(" more "),c])}const u=a(n,[["render",s],["__file","Flink容错机制.html.vue"]]);export{u as default};
