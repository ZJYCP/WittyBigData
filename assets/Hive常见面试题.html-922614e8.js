import{_ as e,V as i,W as l,X as a,Z as r,a1 as o}from"./framework-25aba5a5.js";const t={},d=r("p",null,"Hive常见面试题",-1),n=o(`<h2 id="hive内部表和外部表的区别" tabindex="-1"><a class="header-anchor" href="#hive内部表和外部表的区别" aria-hidden="true">#</a> Hive内部表和外部表的区别</h2><p>使用上：</p><ul><li>未被external修饰的是内部表</li><li>被external修饰的为外部表</li></ul><p>具体区别：</p><ol><li>内部表由Hive自身管理，外部表数据由HDFS管理</li><li>内部表的存储位置是<code>hive.metastore.warehouse.dir</code>（默认/user/hive/warehouse)，外部表数据的存储位置由自己指定</li><li>删除内部表会直接删除元数据及存储数据；删除外部表仅会删除元数据，HDFS上的文件并不会被删除</li></ol><h2 id="hive有索引吗" tabindex="-1"><a class="header-anchor" href="#hive有索引吗" aria-hidden="true">#</a> Hive有索引吗</h2><p>Hive支持索引 3.0版本之前</p><p>Hive不支持主键或者外键，提供的功能有限，效率不高</p><ul><li>适用的场景：</li></ul><p>适用于不更新的静态字段，以免重建索引数据，每次建立、更新数据后，都要重建索引以构建索引表</p><ul><li>Hive索引的机制</li></ul><p>在指定列上建立索引，会产生一张索引表，包括：索引列的值、该值对应的HDFS文件路径、该值在文件中的偏移量</p><p>在新版本中的Hive中已经被废弃</p><p>自动重写的物化视图替代了索引的功能</p><h2 id="运维如何对hive进行调度" tabindex="-1"><a class="header-anchor" href="#运维如何对hive进行调度" aria-hidden="true">#</a> 运维如何对hive进行调度</h2><ol><li>将hive的sql定义在脚本中</li><li>使用azkaban或者oozie进行任务的调度</li><li>监控任务调度页面</li></ol><h2 id="orc、parquet等列式存储的优点" tabindex="-1"><a class="header-anchor" href="#orc、parquet等列式存储的优点" aria-hidden="true">#</a> ORC、Parquet等列式存储的优点</h2><h2 id="数据建模用的哪些模型" tabindex="-1"><a class="header-anchor" href="#数据建模用的哪些模型" aria-hidden="true">#</a> 数据建模用的哪些模型</h2><ol><li>星型模型</li></ol><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230612164858331.png" alt="星型模型" tabindex="0" loading="lazy"><figcaption>星型模型</figcaption></figure><p>以事实表为中心，所有的维度表直接连接在事实表上</p><ul><li>维表只和事实表关联，维表之间没有关联</li><li>每个维表主键为单列，且该主键放置在事实表中，作为两边连接的外键</li><li>以事实表为核心，维表围绕核心呈星形分布</li></ul><ol start="2"><li>雪花模型</li></ol><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230612165119630.png" alt="image-20230612165119630" tabindex="0" loading="lazy"><figcaption>image-20230612165119630</figcaption></figure><p>雪花模型是对星型模型的扩展，雪花模型的维度表是可以拥有其他维度表的。这种模型比星型更规范一些，但是不容易理解和维度，性能方面也更低</p><ol start="3"><li>星座模型</li></ol><figure><img src="https://blog-1252832257.cos.ap-shanghai.myqcloud.com/image-20230612165246096.png" alt="image-20230612165246096" tabindex="0" loading="lazy"><figcaption>image-20230612165246096</figcaption></figure><p>星座模型也是星型模型的延伸，星座模型基于多张事实表，而且共享维度信息。</p><p>在业务后期中，绝大部分维度建模都采用的是星座模型。</p><h2 id="为什么要读数据仓库分层" tabindex="-1"><a class="header-anchor" href="#为什么要读数据仓库分层" aria-hidden="true">#</a> 为什么要读数据仓库分层</h2><ol><li>用时间换空间，通过大量的预处理来提升应用系统的用户体验，会存在大量的冗余数据</li><li>如果不分层的话，如果源业务系统的业务规则发生变化会影响整个数据清洗过程，工作量巨大。</li><li>通过数据分层管理可以简化数据清洗的过程。 比较容易确保每一个步骤的正确性</li></ol><h2 id="使用hive解析json字符串" tabindex="-1"><a class="header-anchor" href="#使用hive解析json字符串" aria-hidden="true">#</a> 使用hive解析json字符串</h2><ol><li>将json以字符串的形式整个入hive表，然后通过使用udf函数解析已经导入到hive中的数据，比如使用<code>lateral view json_tuple</code>的方法，或许所需要的列明</li><li>在导入之前将json拆成各个字段，导入hive的表数据是解析过得，使用第三方的<strong>SerDe</strong></li></ol><h2 id="sort-by和order-by的区别" tabindex="-1"><a class="header-anchor" href="#sort-by和order-by的区别" aria-hidden="true">#</a> sort by和order by的区别</h2><p>order by 对输入进行全局排序，因此只有一个reducer</p><p>sort by不是全局排序，sort by 只能保证每个reducer的输出有序</p><h2 id="数据倾斜怎么解决" tabindex="-1"><a class="header-anchor" href="#数据倾斜怎么解决" aria-hidden="true">#</a> 数据倾斜怎么解决</h2><p>原因</p><ul><li>空值引发的数据倾斜</li><li>不同数据类型引发的数据倾斜</li><li>不可拆分大文件引发的数据倾斜</li><li>数据膨胀引发的数据倾斜</li><li>表连接时引发的数据倾斜</li><li>确实无法减少数据量引发的数据倾斜</li></ul><p>left join和right join 不会对关联的字段自动去除null值</p><p>对于inner join，会自动去除null值</p><h2 id="hive小文件过多怎么处理" tabindex="-1"><a class="header-anchor" href="#hive小文件过多怎么处理" aria-hidden="true">#</a> Hive小文件过多怎么处理</h2><ol><li><strong>使用hive自带的concatenate命令，自动合并小文件</strong></li></ol><ul><li>对于非分区表</li></ul><p><code>alter table A concatenate</code></p><ul><li>对于分区表</li></ul><p><code>alter table B partition(day=20200211) concatenate</code></p><p>注意：</p><ol><li><p>Concatenate 只支持RCFILE和ORC文件类型</p></li><li><p>不能指定合并后的数量，但可以多次执行</p></li><li><p>多次使用后不再变化，和参数<code>mapreduce.input.fileinputformat.split.minsize=256mb</code>设置有关，可以设置文件最小的size</p></li><li><p><strong>调整参数减少map数量</strong></p></li></ol><p>执行map前进行小文件合并</p><p>在mapper中将多个小文件合成一个split作为输入</p><p><code>set hive.input.format = org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;</code></p><ol start="3"><li><strong>减少Reduce的数量</strong></li></ol><p>reduce决定了输出文件的个数，调整reduce可以控制hive表的文件数量</p><ul><li>直接设置Reduce个数</li></ul><p><code>set mapreduce.job.reduces=10</code></p><ul><li>设置每个reduce的大小，hive会根据数据总大小确定一个reduce个数</li></ul><p><code>set hive.exec.reducers.bytes.per.reducer=5120000000</code></p><p>通过分区函数，让数据更加均衡的进入每个reduce</p><div class="language-hive line-numbers-mode" data-ext="hive"><pre class="language-hive"><code>insert overwrite table A partition(dt)
select * from B distribute by rand()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>使用hadoop的archive将小文件归档</strong></li></ol><div class="language-hive line-numbers-mode" data-ext="hive"><pre class="language-hive"><code>ALTER TABLE A ARCHIVE PARTITION(dt=&#39;2022-12-24&#39;,hr=&#39;12&#39;)
ALTER TABLE A UNARCHIVE PARTITION(dt=&#39;2022-12-24&#39;,hr=&#39;12&#39;)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hive优化" tabindex="-1"><a class="header-anchor" href="#hive优化" aria-hidden="true">#</a> Hive优化</h2><ol><li><strong>数据存储及压缩</strong></li></ol><p>存储格式：orc、parquet</p><p>压缩：snappy</p><p>与textfile相比，orc占有更少的存储</p><p>降低IO读写，降低网络传输量，节省内存</p><ol start="2"><li><strong>通过调参优化</strong></li></ol><p>并行执行，调节parallel参数</p><p>调节JVM参数</p><p>设置map、reduce的参数，开启strict mode模式</p><p>关闭推测执行设置</p><ol start="3"><li><p><strong>有效地减少数据集，将大表拆分成子表；结合使用外部表和分区表</strong></p></li><li><p><strong>SQL优化</strong></p><ol><li>大表对大表：尽量减少数据集，可以通过分区表，避免全表扫描或者全字段</li><li>大表对小表：设置自动识别小表，将小表放到内存中执行</li></ol></li></ol>`,74);function p(s,h){return i(),l("div",null,[d,a(" more "),n])}const u=e(t,[["render",p],["__file","Hive常见面试题.html.vue"]]);export{u as default};
